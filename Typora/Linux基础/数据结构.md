​	





数据结构简介：https://zhuanlan.zhihu.com/p/623864103

字符集：ASCII

字符集：Unicode

不同不得字符集可以设计不同的编码方案





# 王道数据结构

<img src="./assets/assets.数据结构/image-20240425211045709.png" alt="image-20240425211045709" style="zoom:33%;" />



![image-20240425211703634](./assets/assets.数据结构/image-20240425211703634.png)

## 数据结构三要素

![image-20240425212756212](./assets/assets.数据结构/image-20240425212756212.png)

![image-20240425212729003](./assets/assets.数据结构/image-20240425212729003.png)



#### 空间复杂度

![image-20240425215649560](./assets/assets.数据结构/image-20240425215649560.png)

![image-20240425215138169](./assets/assets.数据结构/image-20240425215138169.png)



##### 递归

![image-20240425215454775](./assets/assets.数据结构/image-20240425215454775.png)

## 1、线性表

![image-20240425220436670](./assets/assets.数据结构/image-20240425220436670.png)

![image-20240425220608674](./assets/assets.数据结构/image-20240425220608674.png)

![image-20240425220640719](./assets/assets.数据结构/image-20240425220640719.png)

### 1.1 顺序表

![image-20240425220923178](./assets/assets.数据结构/image-20240425220923178.png)

#### 1. 静态分配

**顺序表初始化**：有些东西可以不初始化，但是这个里面的`.length` 必须初始化，以保证数据的正确安全。 

![image-20240425231334895](./assets/assets.数据结构/image-20240425231334895.png)

#### 2. 动态分配

注意： sizeof 的参数是 指针的数据类型。

![image-20240425232120283](./assets/assets.数据结构/image-20240425232120283.png)

##### 用代码实现顺序表

注意 sizeof 的参数是成员指针类型

**动态内存分配** ：**顺序表**实现思想

1. **定义结构体** - 结构体变量 —— 系统在系统在（栈区？）存放结构体成员名，（成员必须有一个指针，因为要动态分配内存，且是一个顺序表）。
2. **结构体成员初始化** - 方法：单独一个函数，开辟堆内存空间，初始化必要的成员值。
3. **访问结构体成员** - 方法：声明一个指针 指向 结构体成员指针 指向的地址 —— 每一个地址存放所有成员信息。
4. **动态改变数组长度** - 方法：结构体成员指针重新指向程序员开辟的一片堆内存。（这个过程中需要完成所有数据的复制）
5. **释放原来分配的结构体的堆内存。**
6. 注意：结构体实现链表，其成员的特点。 

![image-20240425233358418](./assets/assets.数据结构/image-20240425233358418.png)

**动态分配特点**

![image-20240426002548141](./assets/assets.数据结构/image-20240426002548141.png)



#### 3. 插入操作

![image-20240426004658713](./assets/assets.数据结构/image-20240426004658713.png)

#### 4. 删除操作

![image-20240426004754295](./assets/assets.数据结构/image-20240426004754295.png)

#### 5. 查找

**1、按位查找**

![image-20240426005724095](./assets/assets.数据结构/image-20240426005724095.png)

**2、按值查找**

C语言中俩结构体变量不能直接比较，C++中俩结构体变量能直接比较。

![image-20240426010945744](./assets/assets.数据结构/image-20240426010945744.png)

### 1.2 链式表

单链表

![image-20240426011544237](./assets/assets.数据结构/image-20240426011544237.png)

#### 1. 实现一个单链表 

LNODE、LinkList

注意：sizeof 的参数是结构体名。

![image-20240427191637764](./assets/assets.数据结构/image-20240427191637764.png)

##### 不带头结点的单链表

不带头结点的单链表 即结构体初始化时头指针指向 空NULL，且不申请堆空间。

![image-20240427192527764](./assets/assets.数据结构/image-20240427192527764.png)

##### 带头结点的单链表

头指针指向结构体第一个节点的地址指针，但是这个地址指针并不存放数据，下一个地址指针才会存放数据。

![image-20240427192912113](./assets/assets.数据结构/image-20240427192912113.png)

#### 2. 插入

##### 按位序插入（带头结点）

1. 获取第 i-1 个节点 的地址，赋值给 节点 p
2. 申请一个新节点地址，命名为 \*s
3. 配置 节点 s 的 数据 和 地址指针 
4. 将第 i-1 个节点的地址指针 指向节点 s 的地址

![image-20240427195958630](./assets/assets.数据结构/image-20240427195958630.png)

##### 按位序插入（不带头结点）

感觉代码有问题（i=1时）

![image-20240427200316589](./assets/assets.数据结构/image-20240427200316589.png)

##### 指定节点前插

![image-20240427201512060](./assets/assets.数据结构/image-20240427201512060.png)

#### 3. 删除

##### 按位序删除

- 那么指针存放在哪呢，
- 局部变量相当于全局变量了？

![image-20240427202758175](./assets/assets.数据结构/image-20240427202758175.png)

##### 指定节点删除

![image-20240427204842390](./assets/assets.数据结构/image-20240427204842390.png)



#### 4.查找

##### 按位查找

##### 按值查找

![image-20240427205621189](./assets/assets.数据结构/image-20240427205621189.png)

#### 5.单链表的建立

1. 初始化一个单链表
2. 每次取一个数据，插入链表

##### 头插法

1. 俩个节点，一个节点始终为表尾，一个节点存储新数据 
2. 

![image-20240427213840043](./assets/assets.数据结构/image-20240427213840043.png)

##### 尾插法

链表的逆置

![image-20240427220854308](./assets/assets.数据结构/image-20240427220854308.png)

#### 6.双链表

![image-20240427221802334](./assets/assets.数据结构/image-20240427221802334.png)

##### 双链表初始化

![image-20240427221159804](./assets/assets.数据结构/image-20240427221159804.png)

##### 双链表插入

![image-20240427221447686](./assets/assets.数据结构/image-20240427221447686.png)

##### 双链表删除

![image-20240427221613526](./assets/assets.数据结构/image-20240427221613526.png)

##### 双链表遍历

![image-20240427221730724](./assets/assets.数据结构/image-20240427221730724.png)

#### 7. 循环链表

![image-20240427224412340](./assets/assets.数据结构/image-20240427224412340.png)

##### 循环单列表

如果让单列表的指针 L 指向循环单列表的尾部，能够很快找到单列表的尾部和头部。

![image-20240427221955088](./assets/assets.数据结构/image-20240427221955088.png)

##### 循环双列表

![image-20240427222543912](./assets/assets.数据结构/image-20240427222543912.png)

####  8.静态链表

##### 静态链表原理

![image-20240427233033742](./assets/assets.数据结构/image-20240427233033742.png)

##### 静态链表建立

![image-20240427232536152](./assets/assets.数据结构/image-20240427232536152.png)

### 1.3 对比

|          |                              |            |
| -------- | ---------------------------- | ---------- |
| 逻辑结构 | 都是线性结构                 |            |
| 存储结构 | 连续内存、只需要存储数据本身 | 随机存储、 |

![image-20240427233443197](./assets/assets.数据结构/image-20240427233443197.png)

![image-20240427234421325](./assets/assets.数据结构/image-20240427234421325.png)

#### 1. 创建不同

![image-20240427233637179](./assets/assets.数据结构/image-20240427233637179.png)

#### 2. 销毁不同

![image-20240427233926602](./assets/assets.数据结构/image-20240427233926602.png)

#### 3. 增、删不同

![image-20240427234124551](./assets/assets.数据结构/image-20240427234124551.png)

#### 4. 查不同

![image-20240427234300831](./assets/assets.数据结构/image-20240427234300831.png)



## 2、栈 stack

### 2.1 栈的基本概念

定义

![image-20240427234844640](./assets/assets.数据结构/image-20240427234844640.png)

栈的基本操作

![image-20240427235036304](./assets/assets.数据结构/image-20240427235036304.png)

### 2.2  顺序栈

![image-20240428003653103](./assets/assets.数据结构/image-20240428003653103.png)

#### 1. 顺序栈定义

Sq：sequence

![image-20240427235536674](./assets/assets.数据结构/image-20240427235536674.png)

#### 2. 顺序栈初始化

![image-20240428002857976](./assets/assets.数据结构/image-20240428002857976.png)

#### 3. 进栈

![image-20240428002834895](./assets/assets.数据结构/image-20240428002834895.png)

#### 4. 出栈

![image-20240428002955070](./assets/assets.数据结构/image-20240428002955070.png)

#### 5. 共享栈

![image-20240428003645514](./assets/assets.数据结构/image-20240428003645514.png)

### 2.3 链栈

```c
// 链式栈节点
typedef struct node
{
    datatype data;
    struct node *next;
}node;

// 链式栈管理结构体
typedef struct linkStack
{
    node *top; // 链式栈栈顶指针
    int  size; // 链式栈当前元素个数
}linkStack;

// 初始化空栈
linkStack * initStack(void)
{
	linkStack * s = (linkStack *)malloc(sizeof(linkStack));
    if(s != NULL)
    {
        s->top  = NULL;
        s->size = 0;
    }
	return s;
}

// 判断栈是否为空
bool isEmpty(linkStack *s)
{
	return (top->size == 0);
}

// 入栈
bool push(linkStack *s, datatype data)
{
    // 创建链表节点
    node *new = (node *)malloc(sizeof(node));
	if(new == NULL)
		return false;

	new->data = data;
	new->next = s->top; // 新节点执行先前的节点
	s->top = new; //栈顶指针重新指向栈顶
	s->size++; // 更新栈元素个数
	return true;
}

// 出栈
bool pop(linkStack *s, datatype *pm)
{
	if(isEmpty(s))
		return false;

	linkStack *tmp = s->top;

	s->top = tmp->next; // 将原栈顶元素剔除出栈
    tmp->next = NULL; //保证数据安全

    *pm = tmp->data; // 返回栈顶元素
	free(tmp); // 并释放节点

	return true;
}

// 取栈顶元素
bool top(linkStack *s, datatype *pm)
{
	if(isEmpty(s))
		return false;

    *pm = s->top->data; // 返回栈顶元素
	return true;
}
```





## 3、队列 Queue FIFO

先进先出

![img](./assets/assets.数据结构/wKgP3GCJEGGAat_kAADYyYvSH1Y032.gif)

#### 队列基本操作

![image-20240428004042074](./assets/assets.数据结构/image-20240428004042074.png)

#### 3.1 顺序

##### 初始化

![image-20240428004411219](./assets/assets.数据结构/image-20240428004411219.png)

#### 3.2 入队 循环列队

注意判满语判空区别

![image-20240428004720985](./assets/assets.数据结构/image-20240428004720985.png)

##### 出队

![image-20240428005013020](./assets/assets.数据结构/image-20240428005013020.png)

##### 判断队列空满

![image-20240428005359466](./assets/assets.数据结构/image-20240428005359466.png)

![image-20240428005201037](./assets/assets.数据结构/image-20240428005201037.png)

![image-20240428005301198](./assets/assets.数据结构/image-20240428005301198.png)





## 4、串

#### 定义

![image-20240428010628159](./assets/assets.数据结构/image-20240428010628159.png)

![image-20240428010602073](./assets/assets.数据结构/image-20240428010602073.png)

### 串的基本操作

![image-20240428011252029](./assets/assets.数据结构/image-20240428011252029.png)

#### 存储

![image-20240428012203702](./assets/assets.数据结构/image-20240428012203702.png)

![image-20240428012132944](./assets/assets.数据结构/image-20240428012132944.png)

![image-20240428012259052](./assets/assets.数据结构/image-20240428012259052.png)

#### 求子串

![image-20240428012407942](./assets/assets.数据结构/image-20240428012407942.png)

#### 比较

![image-20240428012524344](./assets/assets.数据结构/image-20240428012524344.png)

#### 定位

![image-20240428013119172](./assets/assets.数据结构/image-20240428013119172.png)















数据类型、抽象数据类型

![image-20240425213215449](./assets/assets.数据结构/image-20240425213215449.png)



### 朴素匹配算法

![image-20240428013927180](./assets/assets.数据结构/image-20240428013927180.png)

![image-20240428013839616](./assets/assets.数据结构/image-20240428013839616.png)

### KMP算法

![image-20240428014810099](./assets/assets.数据结构/image-20240428014810099.png)



## 5、树

### 基本概念

森林：互不相交的数的集合

![image-20240514112312423](./assets/assets.数据结构/image-20240514112312423.png)

![image-20240514112729258](./assets/assets.数据结构/image-20240514112729258.png)

![image-20240514112506503](./assets/assets.数据结构/image-20240514112506503.png)

### 二叉树的性质

1. 叶子结点个数比二分结点个数多一个
2. 二叉树第 i 层最多有 2<sup>i-1</sup> 个节点 （2-m）
3. ![image-20240515121407051](./assets/assets.数据结构/image-20240515121407051.png)
4. 

### 特殊二叉树

#### 满二叉树、完全二叉树

![image-20240514113059950](./assets/assets.数据结构/image-20240514113059950.png)

#### 二叉排序树

![image-20240514113358788](./assets/assets.数据结构/image-20240514113358788.png)



#### 平衡二叉树

![image-20240514113545538](./assets/assets.数据结构/image-20240514113545538.png)

### 二叉树的顺序存储

很少使用

![image-20240514120128405](./assets/assets.数据结构/image-20240514120128405.png)

完全二叉树特点

![image-20240514120339787](./assets/assets.数据结构/image-20240514120339787.png)



### 二叉树链式存储

![image-20240514120730461](./assets/assets.数据结构/image-20240514120730461.png)



#### 链式存储

n个结点的二叉链表，公有n+1个空链域

![image-20240514120934021](./assets/assets.数据结构/image-20240514120934021.png)

![image-20240515121650114](./assets/assets.数据结构/image-20240515121650114.png)



### 二叉树遍历

空间复杂度 o(h+1)，h二叉树的高度。

![image-20240514181803846](./assets/assets.数据结构/image-20240514181803846.png)

#### 求树的深度

![image-20240515122803729](./assets/assets.数据结构/image-20240515122803729.png)



#### 先序遍历

根左右

![image-20240515122552283](./assets/assets.数据结构/image-20240515122552283.png)

![image-20240514122919496](./assets/assets.数据结构/image-20240514122919496.png)

![image-20240514122255364](./assets/assets.数据结构/image-20240514122255364.png)

#### 中序遍历

![image-20240514122420374](./assets/assets.数据结构/image-20240514122420374.png)



#### 层序遍历	

##### 思想

![image-20240514123307786](./assets/assets.数据结构/image-20240514123307786.png)

##### 代码实现                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

![image-20240514123503054](./assets/assets.数据结构/image-20240514123503054.png)

### 线索二叉树

![image-20240514181608567](./assets/assets.数据结构/image-20240514181608567.png)

#### 中序线索二叉树

更方便的找到一个线索的前驱与后继

##### 思想	

![image-20240514180900749](./assets/assets.数据结构/image-20240514180900749.png)

![image-20240514181131949](./assets/assets.数据结构/image-20240514181131949.png)

##### 代码实现

![image-20240514181118860](./assets/assets.数据结构/image-20240514181118860.png)

#### 先序线索二叉树

![image-20240514181244557](./assets/assets.数据结构/image-20240514181244557.png)

![image-20240514181311199](./assets/assets.数据结构/image-20240514181311199.png)

#### 后序线索二叉树

![image-20240514181349833](./assets/assets.数据结构/image-20240514181349833.png)



#### 对比

![image-20240514181513165](./assets/assets.数据结构/image-20240514181513165.png)

### 线索化二叉树

![image-20240514214045369](./assets/assets.数据结构/image-20240514214045369.png)

土方法

![image-20240514182313236](./assets/assets.数据结构/image-20240514182313236.png)

#### 中序线索化

中序遍历二叉树的过程中，一边遍历、一边处理N+1个空节点。

![image-20240514182852318](./assets/assets.数据结构/image-20240514182852318.png)

![image-20240514183322503](./assets/assets.数据结构/image-20240514183322503.png)

#### 先序线索化

注意先序线索化中的问题：在3处：当处理完中序函数后，3的左孩子指向2； 然后又会处理左孩子函数，这样就会无限循环。

<img src="./assets/assets.数据结构/image-20240514212626627.png" alt="image-20240514212626627" style="zoom:33%;" />

![image-20240514210644218](./assets/assets.数据结构/image-20240514210644218.png)

#### 后序线索化

![image-20240514213601732](./assets/assets.数据结构/image-20240514213601732.png)

![image-20240514213854881](./assets/assets.数据结构/image-20240514213854881.png)



### 线索二叉树找中序后继

![image-20240515142353057](./assets/assets.数据结构/image-20240515142353057.png)

基于遍历的

![image-20240515135813881](./assets/assets.数据结构/image-20240515135813881.png)



### 树的存储结构

![image-20240515144447252](./assets/assets.数据结构/image-20240515144447252.png)

#### 孩子兄弟表示法

![image-20240515143726527](./assets/assets.数据结构/image-20240515143726527.png)

![image-20240515144013616](./assets/assets.数据结构/image-20240515144013616.png)

#### 森林转二叉树

![image-20240515144212166](./assets/assets.数据结构/image-20240515144212166.png)

#### 二叉树转森林

![image-20240515144319780](./assets/assets.数据结构/image-20240515144319780.png)



### 树的遍历

先跟后根遍历：深度优先遍历

#### 树的先根遍历

![image-20240515145004549](./assets/assets.数据结构/image-20240515145004549.png)

#### 树的后根遍历

第二次到来时才会访问

![image-20240515145227579](./assets/assets.数据结构/image-20240515145227579.png)

#### 树的层次遍历



![image-20240515150302902](./assets/assets.数据结构/image-20240515150302902.png)



### 哈夫曼树

![image-20240515150525019](./assets/assets.数据结构/image-20240515150525019.png)

![image-20240515150801372](./assets/assets.数据结构/image-20240515150801372.png)

![image-20240515150843289](./assets/assets.数据结构/image-20240515150843289.png)

#### 哈夫曼编码

![image-20240515151757538](./assets/assets.数据结构/image-20240515151757538.png)

![image-20240515151725250](./assets/assets.数据结构/image-20240515151725250.png)



## 6、图

### 基础

#### 度、入度、出度

![image-20240515154126247](./assets/assets.数据结构/image-20240515154126247.png)

#### 顶点顶点关系

![image-20240515154354362](./assets/assets.数据结构/image-20240515154354362.png)

#### 子图

![image-20240515154643858](./assets/assets.数据结构/image-20240515154643858.png)

### 图的存储

![image-20240515160449981](./assets/assets.数据结构/image-20240515160449981.png)

#### 带权图

![image-20240515161752774](./assets/assets.数据结构/image-20240515161752774.png)





## 7、排序

![image-20240515163157461](./assets/assets.数据结构/image-20240515163157461.png)

​	算法的稳定性

![image-20240515162739368](./assets/assets.数据结构/image-20240515162739368.png)

### 插入排序

注意时间空间复杂度、稳定性

![image-20240515164356173](./assets/assets.数据结构/image-20240515164356173.png)

![image-20240515165059825](./assets/assets.数据结构/image-20240515165059825.png)



### 希尔排序

局部有序

![image-20240515184212856](./assets/assets.数据结构/image-20240515184212856.png)

![image-20240515184352244](./assets/assets.数据结构/image-20240515184352244.png)

<img src="./assets/assets.数据结构/image-20240515184510304.png" alt="image-20240515184510304" style="zoom:67%;" />

### 冒泡排序

可以用于链表

交换排序：冒泡排序、快速排序。

![image-20240515185812797](./assets/assets.数据结构/image-20240515185812797.png)

<img src="./assets/assets.数据结构/image-20240515185412690.png" alt="image-20240515185412690" style="zoom:67%;" />

<img src="./assets/assets.数据结构/image-20240515185659769.png" alt="image-20240515185659769" style="zoom:67%;" />



### 快速排序

![image-20240515192453258](./assets/assets.数据结构/image-20240515192453258.png)

![image-20240515224236427](./assets/assets.数据结构/image-20240515224236427.png)

![image-20240515191527721](./assets/assets.数据结构/image-20240515191527721.png)

<img src="./assets/assets.数据结构/image-20240515191936907.png" alt="image-20240515191936907" style="zoom: 67%;" />

<img src="./assets/assets.数据结构/image-20240515192257337.png" alt="image-20240515192257337" style="zoom:67%;" />



### 简单选择排序

选择排序：简单选择排序、堆排序

<img src="./assets/assets.数据结构/image-20240515212418266.png" alt="image-20240515212418266" style="zoom: 67%;" />

<img src="./assets/assets.数据结构/image-20240515213518082.png" alt="image-20240515213518082" style="zoom:67%;" />



### 堆排序



<img src="./assets/assets.数据结构/image-20240515213646202.png" alt="image-20240515213646202" style="zoom: 67%;" />

<img src="./assets/assets.数据结构/image-20240515214134363.png" alt="image-20240515214134363" style="zoom: 67%;" />

<img src="./assets/assets.数据结构/image-20240515214316268.png" alt="image-20240515214316268" style="zoom: 67%;" />

<img src="./assets/assets.数据结构/image-20240515213920678.png" alt="image-20240515213920678" style="zoom: 67%;" />

#### 建立





### 归并合并 Merge

<img src="./assets/assets.数据结构/image-20240515222547213.png" alt="image-20240515222547213" style="zoom:67%;" />



<img src="./assets/assets.数据结构/image-20240515222732067.png" alt="image-20240515222732067" style="zoom:67%;" />





### 外部排序



#### 理论

<img src="./assets/assets.数据结构/image-20240515230141253.png" alt="image-20240515230141253" style="zoom:50%;" />

<img src="./assets/assets.数据结构/image-20240515230206611.png" alt="image-20240515230206611" style="zoom: 50%;" />

<img src="./assets/assets.数据结构/image-20240515230312181.png" alt="image-20240515230312181" style="zoom: 67%;" />

#### 优化

![image-20240515230707455](./assets/assets.数据结构/image-20240515230707455.png)

![image-20240515230906310](./assets/assets.数据结构/image-20240515230906310.png)





# 粤嵌数据结构



### **性能分析**

不同的排序算法性能不同，详细性能数据如下表所示。

| 排序算法           | 平均 T(n)*T*(*n*)        | 最坏 T(n)*T*(*n*) | 最好 T(n)*T*(*n*)        | 空间复杂度               | 稳定性 |
| ------------------ | ------------------------ | ----------------- | ------------------------ | ------------------------ | ------ |
| 选择排序（最垃圾） | O(n2)*O*(*n*2)           | O(n2)*O*(*n*2)    | O(n2)*O*(*n*2)           | O(1)*O*(1)               | 不稳定 |
| 插入排序           | O(n2)*O*(*n*2)           | O(n2)*O*(*n*2)    | O(n)*O*(*n*)             | O(1)*O*(1)               | 稳定   |
| 冒泡排序           | O(n2)*O*(*n*2)           | O(n2)*O*(*n*2)    | O(n)*O*(*n*)             | O(1)*O*(1)               | 稳定   |
| 快速排序           | O(nlog⁡2n)*O*(*n*log2*n*) | O(n2)*O*(*n*2)    | O(nlog⁡2n)*O*(*n*log2*n*) | O(nlog⁡2n)*O*(*n*log2*n*) | 不稳定 |
| 希尔排序           | O(n1.3)*O*(*n*1.3)       | O(n2)*O*(*n*2)    | O(n)*O*(*n*)             | O(1)*O*(1)               | 不稳定 |

从表中可以得到一些简单的指导思路：

1. 选择排序、插入排序和冒泡排序思路简单，但时间效率较差，只适用于数据样本较小的场合，这几种算法的好处是不需要额外开辟空间，空间复杂度是常量。
2. 希尔排序是插入排序的改进版，在平均情况下时间效率要比直接插入法好很多，也不需要额外开辟空间，要注意的是希尔排序是不稳定排序。
3. 快速排序是所有排序算法中时间效率最高的，但由于快排是一种递归运算，对内存空间要求较高，当数据量较大时，会消耗较多的内存。



### 插入排序

插入排序的思路也很简单：假设前面已经有i*i*节点是有序的，那么就从第i+1*i*+1个节点开始，插入到前面的i*i*个节点的合适的位置中。由于第一个元素自身总是有序的，因此从第2个开始，不断插入前面的有序序列，直到全部排列完毕。

假设总共有n*n*个节点，那么总共需要将n−1*n*−1个节点插入到有序序列中，而插入节点时需要找到合适的位置，显然这个查找的过程时间复杂度是O(n−i)*O*(*n*−*i*)，因此插入排序的时间复杂度是O(n−1)(n−i)*O*(*n*−1)(*n*−*i*)，即O(n2)*O*(*n*2)

<img src="./assets/assets.数据结构/wKgA3V-hBOmAQyHCAAYsDJCCNjc848.gif" alt="img" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdbool.h>

int swap_count = 0;
int comp_count = 0;

void show(int data[], int len)
{
    int i;
    for(i=0; i<len; ++i)
    {
        printf("%d\t", data[i]);
    }
    printf("\n");
}

void insertionSort(int data[], int len)
{
    if(len <= 1)
        return;

    int i, j;
    for(i=1; i<len; i++)
    {
        int tmp = data[i];

        for(j=i-1; j>=0; j--)
        {
            comp_count++;
            if(data[j] < tmp)
            {
                break;
            }
            else
            {
                swap_count++;
                data[j+1] = data[j];
            }
        }
        swap_count++;
        data[j+1] = tmp;
    }
}

int main(int argc, char **argv)
{
    srand(time(NULL));

    int i, data[100];
    for(i=0; i<100; ++i)
    {
        data[i] = rand() % 1000;
    }
    printf("随机序列: ");
    show(data, 100);

    printf("插入排序: ");
    insertionSort(data, 100);
    show(data, 100);

    printf("总共比较次数: %d\n", comp_count);
    printf("总共移动次数: %d\n", swap_count);

    return 0;
}
```



### 冒泡

首先引入两个概念：

- 顺序：如果两个数据的位置符合排序的需要，则称它们是顺序的。
- 逆序：如果两个数据的位置不符合排序需要，则称它们是逆序的。

冒泡排序基于这样一种简单的思路：从头到尾让每两个相邻的元素进行比较，顺序就保持位置不变，逆序就交换位置。可以预料，经过一轮比较，序列中具有“极值”的数据，将被挪至序列的末端。

假如序列中有n*n*个数据，那么在最极端的情况下，只需要经过n−1*n*−1轮的比较，则一定可以将所有的数据排序完毕。冒泡法排序的时间复杂度是O(n2)*O*(*n*2)

<img src="./assets/assets.数据结构/wKgA3V-hBUyAE_SKAAcfyrpge78453.gif" alt="img" style="zoom:67%;" />

```c
#include <stdio.h>

int comp_count = 0; // 数据比较次数
int swap_count = 0; // 数据交换次数

void show(int data[], int len)
{
    int i;
    for(i=0; i<len; ++i)
    {
        printf("%d\t", data[i]);
    }
    printf("\n");
}

void swap(int *a, int *b)
{
    swap_count++;

    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

void bubbleSort(int data[], int len)
{
    int k=0;
    while(1)
    {
        bool done = true;

        int i;
        for(i=0; i<len-1-k; i++)
        {
            comp_count++;

            if(data[i] <= data[i+1])
            {
                continue;
            }
        
            swap(&data[i], &data[i+1]);
            done = false;
        }

        if(done)
            break;
        k++;
    }
}

int main(int argc, char **argv)
{
    srand(time(NULL));

    int i, data[100];
    for(i=0; i<100; ++i)
    {
        data[i] = rand() % 1000;
    }
    printf("随机序列: ");
    show(data, 100);

    bubbleSort(data, 100);  // 按升序排列
    printf("冒泡排序: ");
    show(data, 100);

    printf("总共比较次数: %d\n", comp_count);
    printf("总共交换次数: %d\n", swap_count);
    return 0;
}
```



### 快速排序

快排是一种递归思想的排序算法，先比较其他的排序算法，它需要更多内存空间，但快排的语句频度是最低的，理论上时间效率是最高的。

快速排序的基本思路是：在待排序序列中随便选取一个数据，作为所谓“支点”，然后所有其他的数据与之比较，以从小到大排序为例，那么比支点小的统统放在其左边，比支点大的统统放在其右边，全部比完之后，支点将位与两个序列的中间，这叫做一次划分（partition）。

<img src="./assets/assets.数据结构/wKgA3V-hBZyANi0cAAA_WfR9c3g262.png" alt="img" style="zoom:50%;" />

一次划分之后，序列内部也许是无序的， 但是序列与支点三者之间，形成了一种基本的有序状态，接下去使用相同的思路，递归地对左右两边的子序列进行排序，直到子序列的长度小于等于1为止。

![img](./assets/assets.数据结构/wKgA3V-hBXyAF1kOAAUc1UiMTlA345.gif)

```c
#include <stdio.h>

int comp_count = 0;
int swap_count = 0;

void show(int data[], int len)
{
    int i;
    for(i=0; i<len; ++i)
    {
        printf("%d\t", data[i]);
    }
    printf("\n");
}

void swap(int *a, int *b)
{
    swap_count++;

    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int data[], int len)
{
    if(len <= 1)
        return 0;

    int i = 0;
    int j = len-1;
    while(i < j)
    {
        // 从右向左比较，顺序j--，逆序交换
        comp_count++;
        while(data[i]<=data[j] && i<j)
            j--;
        swap(&data[i], &data[j]);

        // 从左向右比较，顺序i++，逆序交换
        comp_count++;
        while(data[i]<=data[j] && i<j)
            i++;
        swap(&data[i], &data[j]);
    }

    return i;
}

void quickSort(int data[], int len)
{
    if(len <= 1)
        return;

    int pivot = partition(data, len);

    quickSort(data, pivot);
    quickSort(data+pivot+1, len-pivot-1);
}

int main(int argc, char **argv)
{
    srand(time(NULL));

    int i, data[100];
    for(i=0; i<100; ++i)
    {
        data[i] = rand() % 1000;
    }
    printf("随机序列: ");
    show(data, 100);

    printf("快速排序: ");
    quickSort(data, 100);
    show(data, 100);

    printf("总共比较次数: %d\n", comp_count);
    printf("总共交换次数: %d\n", swap_count);

    return 0;
}
```







# 实操

## 1、链表

### 1.1 各表特点

**顺序表**

顺序存储中，由于逻辑关系是用物理位置来表达的，因此从上述示例代码可以很清楚看到，增删数据都非常困难，需要成片地移动数据。顺序表对数据节点的增删操作是很不友好的。

总结其特点如下：

- 优点

  1. 不需要多余的信息来记录数据间的关系，存储密度高

  1. 所有数据顺序存储在一片连续的内存中，支持立即访问任意一个随机数据，比如上述顺序表中第𝑖*i*个节点是 s->data[i]

- 缺点

  1. 插入、删除时需要保持数据的物理位置反映其逻辑关系，一般需要成片移动数据

  1. 当数据节点数量较多时，需要一整片较大的连续内存空间

  1. 当数据节点数量变化剧烈时，内存的释放和分配不灵活

**链表**

节点存储位置随机，他们之间的逻辑关系用指针来确定，跟物理存储位置无关
增删数据都非常迅速，不需要移动任何数据。
另外，又由于位置与逻辑关系无关，因此也无法直接访问某一个指定的节点，只能从头到尾按遍历的方式一个个找到想要的节点。

简单讲，链式存储的优缺点跟顺序存储几乎是相对的。

- 优点
  1. 插入、删除时只需要调整几个指针，无需移动任何数据
  2. 当数据节点数量较多时，无需一整片较大的连续内存空间，可以灵活利用离散的内存
  3. 当数据节点数量变化剧烈时，内存的释放和分配灵活，速度快
- 缺点
  1. 在节点中，需要多余的指针来记录节点之间的关联。
  2. 所有数据都是随机存储的，不支持立即访问任意一个随机数据。

**双链表**

经过单链表、双链表的学习，可以总结链表的适用场合：

- 适合用于节点数目不固定，动态变化较大的场合
- 适合用于节点需要频繁插入、删除的场合
- 适合用于对节点==查找效率不十分敏感==的场合

### 1.2 顺序表

#### 1、静态

```c
// 注意结构体变量名访问结构体成员，与结构体变量地址访问结构体成员的区别
#include <stdio.h>
#include <string.h>
 
#define MAX_SIZE 20

// 定义结构体
typedef struct 
{
    char name[MAX_SIZE];  //静态线性表
    int length;
} StList;  // sequence table

 // 初始化序列表
void initStList(StList *stList)
{
    stList->length = MAX_SIZE;
}

int main()
{
    char str[MAX_SIZE] ={0};
    printf("请输入字符串：" );
    scanf("%s", str);
    printf("您输入的字符串是：%s\n", str);

    StList stList;
    initStList(&stList);
    printf("初始化成功！\n");
    printf("sizeof(stList) %ld\n", sizeof(stList));
    printf("stList.name    %p\n", stList.name);
    printf("stList.length  %d\n", stList.length);

    //写入数据
    // UpdataSeqList(seqList, str, sizeof(str));

    for ( int i=0; i < stList.length; i++ )
    {
        stList.name[i] = str[i];
        printf("stList.name[%d] = %c \n", i, stList.name[i]);
    }

    return 0;
}

```

#### 2、动态

```c
//动态
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
 
#define InitSize 0
#define MAX_SIZE 20

// 定义结构体
typedef struct 
{
    char *data;
    int length;
    int maxSize; 
    // char aaa;
} StList;  // sequence table

 // 初始化序列表
void InitStList(StList *stList)
{
    stList->data = (char*)malloc(InitSize * sizeof(char));
    stList->length = InitSize;
    stList->maxSize = MAX_SIZE;
    printf("初始化成功！\n");
}

// 向序列表中写入数据
bool AddSeqList(StList *stList, char *str, int len)
{
    if (stList->length + len > stList->maxSize) {
        printf("字符串长度超过最大长度！\n");
        return false;
    }
    char *oldData = stList->data;
    // 申请空间
    stList->data = (char *)malloc((stList->length + len)* sizeof(char));
    if (stList->data == NULL) {
        printf("内存分配失败！\n");
        stList->data = oldData;
        return false;
    } else {
        for (int i = 0; i < stList->length; i++)
        {
            stList->data[i] = oldData[i];
        }
        for (int i = 0; i < len; i++)
        {
            stList->data[stList->length + i] = str[i];
        }
    }
    stList->length += len;

    free(oldData);  //为什么老地址时放与否，会影响新地址的释放
    return true;
}

// 打印结构体信息
void AddrAanData(StList *stList)
{
    printf("\nsizeof(stList) = %ld\n", sizeof(stList)); // 打印的是结构体名地址大小
    printf("sizeof(*stList) = %ld\n", sizeof(*stList)); // 打印的是结构体大小
    printf("sizeof(stList.data) = %ld\n", sizeof(stList->data));
    printf("sizeof(*(stList->data)) = %ld\n", sizeof(*(stList->data)));
    printf("stList          %p\n", &stList);
    printf("stList.data.p   %p\n", stList->data);
    printf("stList.length.p %p\n", &stList->length);
    printf("stList.maxSize.p%p\n", &stList->maxSize);
    printf("stList.length   %d\n", stList->length);
    printf("stList.maxSize  %d\n", stList->maxSize);
}

// 打印顺序表信息
void PrintfList(StList *stList,bool aa)
{
    if (aa) {
        for ( int i=0; i < stList->length; i++ )  // 打印数据
        {
            printf("stList.data[%d] = %c \n", i, stList->data[i]);
        }
    } else {
        printf("字符串长度超过最大长度！\n");
    }
}

//输入数据
void InputStr(char *str)
{
    printf("请输入字符串：" );
    scanf("%s", str);
    printf("您输入的字符串是：%s\n", str);
}

int main()
{
    char str[100] ={0};
    StList stList;
    
    printf("\nsizeof(stList) = %ld\n", sizeof(stList)); // 打印的是结构体大小
    InitStList(&stList);    // 初始化

    AddrAanData(&stList);  // 打印结构体信息

    InputStr(str);        // 输入字符串
    bool aa = false;
    aa = AddSeqList(&stList, str, strlen(str));
    aa = AddSeqList(&stList, str, strlen(str));

    PrintfList(&stList,aa);
    
    
    AddrAanData(&stList);    // 打印结构体信息
    free(stList.data);       // 为什么不会释放普通成员变量的地址
    printf("内存释放成功！");
    AddrAanData(&stList);    // 打印结构体信息
    if (stList.data == NULL) printf("nnnn\n");

    // stList.length = 10;
    // stList.maxSize = 20;
    // AddrAanData(&stList);
    // // InputStr(str);
    // PrintfList(&stList,aa); //打印乱码

    return 0;
}
```

##### 指针初始化

```c
//动态 向尾部添加数据--指针初始化
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
 
#define InitSize 0
#define MaxSize 20

// 定义结构体
typedef struct 
{
    char* data;
    int length;
    int maxSize; 
    // char aaa;
} StList;  // sequence table

StList* InitStList(int maxSize);
bool AddSeqList(StList *stList, char *str, int len);
void AddrAanData(StList *stList);
void PrintfList(StList *stList, bool aa);
void InputStr(char *str);

int main()
{
    char str[100] ={0};
    StList* stList;

    // 初始化
    stList = InitStList(MaxSize); 

    // 打印结构体信息
    AddrAanData(stList);  

    // 向序列表尾中添加数据
    InputStr(str);        // 输入字符串
    bool aa = false;
    aa = AddSeqList(stList, str, strlen(str));
    aa = AddSeqList(stList, str, strlen(str));

    PrintfList(stList,aa);
    
    AddrAanData(stList);    // 打印结构体信息
    free(stList);       // 为什么不会释放普通成员变量的地址
    printf("内存释放成功！");
    AddrAanData(stList);    // 打印结构体信息
    if (stList->data == NULL) printf("nnnn\n");
    if (stList == NULL) printf("AAAA\n");

    // stList->length = 10;
    // stList->maxSize = 20;
    // AddrAanData(stList); 
    // // InputStr(str);
    // PrintfList(stList,aa);  // 段错误 (核心已转储)

    return 0;
}


 // 初始化序列表
StList* InitStList(int maxSize)
{
    StList* stList = (StList*)malloc(sizeof(StList));
    stList->data = (char*)malloc(maxSize * sizeof(char));
    stList->length = 0;
    stList->maxSize = MaxSize;
    printf("初始化成功！\n");
    return stList;
}

// 向序列表尾中写入数据
bool AddSeqList(StList *stList, char *str, int len)
{
    if (stList->length + len > stList->maxSize) {
        printf("字符串长度超过最大长度！\n");
        return false;
    }
    char *oldData = stList->data; // 保存老地址
    // 申请空间
    stList->data = (char *)malloc((stList->length + len)* sizeof(char));
    if (stList->data == NULL) {
        printf("内存分配失败！\n");
        stList->data = oldData;
        return false;
    } else {
        for (int i = 0; i < stList->length; i++) { // 老地址数据
            stList->data[i] = oldData[i];
        }
        for (int i = 0; i < len; i++) { //新添加的数据
            stList->data[stList->length + i] = str[i];
        }
    }
    stList->length += len;

    free(oldData);  //为什么老地址时放与否，会影响新地址的释放
    return true;
}

// 打印结构体信息
void AddrAanData(StList *stList)
{
    printf("\nsizeof(stList) = %ld\n", sizeof(stList)); // 打印的是结构体名地址大小
    printf("sizeof(*stList) = %ld\n", sizeof(*stList)); // 打印的是结构体大小
    printf("sizeof(stList.data) = %ld\n", sizeof(stList->data));
    printf("sizeof(*(stList->data)) = %ld\n", sizeof(*(stList->data)));
    printf("stList          %p\n", &stList);
    printf("stList.data.p   %p\n", stList->data);
    printf("stList.length.p %p\n", &stList->length);
    printf("stList.maxSize.p%p\n", &stList->maxSize);
    printf("stList.length   %d\n", stList->length);
    printf("stList.maxSize  %d\n", stList->maxSize);
}

// 打印顺序表信息
void PrintfList(StList *stList,bool aa)
{
    if (aa) {
        for ( int i=0; i < stList->length; i++ ) { // 打印数据 
            printf("stList.data[%d] = %c \n", i, stList->data[i]);
        }
    } else {
        printf("字符串长度超过最大长度！\n");
    }
}

//输入数据
void InputStr(char *str)
{
    printf("请输入字符串：" );
    scanf("%s", str);
    // printf("您输入的字符串是：%s\n", str);
}

```



#### 3、动态添加

```cpp
//动态
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
 
#define InitSize 0
#define MAX_SIZE 20

// 定义结构体
typedef struct 
{
    char *data;
    int length;
    int maxSize; 
    // char aaa;
} StList;  // sequence table

 // 初始化序列表
void InitStList(StList *stList)
{
    (*stList).data = (char*)malloc(InitSize * sizeof(char));
    stList->length = InitSize;
    stList->maxSize = MAX_SIZE;
    printf("初始化成功！\n");
}

// 向序列表中写入数据
bool AddSeqList(StList *stList, char *str, int len)
{
    if (stList->length + len > stList->maxSize) {
        printf("字符串长度超过最大长度！\n");
        return false;
    }
    char *oudData = stList->data;
    stList->data = (char *)malloc((stList->length + len)* sizeof(char));
    if (stList->data == NULL) {
        printf("内存分配失败！\n");
        stList->data = oudData;
        return false;
    } else {
        for (int i = 0; i < stList->length; i++)
        {
            stList->data[i] = oudData[i];
        }
        for (int i = 0; i < len; i++)
        {
            stList->data[stList->length + i] = str[i];
        }
    }
    stList->length += len;
    return true;
}

// 打印结构体信息
void AddrAanData(StList *stList)
{
    printf("\nsizeof(stList) = %ld\n", sizeof(stList)); // 打印的是结构体名地址大小
    printf("sizeof(*stList) = %ld\n", sizeof(*stList)); // 打印的是结构体大小
    printf("sizeof(stList.data) = %ld\n", sizeof(stList->data));
    printf("sizeof(*(stList->data)) = %ld\n", sizeof(*(stList->data)));
    // printf("%ld\n",sizeof(stList->aaa));

    printf("stList         %p\n", &stList);
    printf("stList.data.p  %p\n", stList->data);
    printf("stList.length  %d\n", *(stList->data));
}

//输入数据
void InputStr(char *str)
{
    printf("请输入字符串：" );
    scanf("%s", str);
    printf("您输入的字符串是：%s\n", str);
}

int main()
{
    char str[100] ={0};
    StList stList;
    
    printf("\nsizeof(stList) %ld\n", sizeof(stList));
    InitStList(&stList);    // 初始化
    printf("sizeof(stList) %ld\n", sizeof(stList));
    
    AddrAanData(&stList);  // 打印结构体信息

    InputStr(str);        // 输入字符串
    bool aa = false;
    aa = AddSeqList(&stList, str, strlen(str));
    aa = AddSeqList(&stList, str, strlen(str));

    if (aa) {
        for ( int i=0; i < stList.length; i++ )  // 打印数据
        {
            printf("stList.data[%d] = %c \n", i, stList.data[i]);
        }
    } else {
        printf("字符串长度超过最大长度！\n");
    }

    // AddrAanData(&stList); // 打印结构体信息

    return 0;
}
```

#### 4、插入



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define INST_SIZE 10
#define MAX_SIZE 100

typedef struct 
{
    char* data;
    int length;
    int maxSize;
} SeqList;

void InitSeqList(SeqList* seqlist);
void PrintfSeqList(SeqList *SeqList);
bool InsterList(SeqList *L, char ch, int i);

int main()
{
    SeqList seqList;
    
    // 初始化
    InitSeqList(&seqList);
    PrintfSeqList(&seqList);

    char a = 'a';
    // 插入
    InsterList(&seqList,a,5);
    PrintfSeqList(&seqList);
}

void InitSeqList(SeqList* seqlist) 
{
    seqlist->data = (char*)malloc(MAX_SIZE * sizeof(char));
    seqlist->length = INST_SIZE;
    seqlist->maxSize = MAX_SIZE;
    for (int i=0; i<INST_SIZE; i++) {
        seqlist->data[i] = i + '0';
    }
}

void PrintfSeqList(SeqList *SeqList)
{
    for (int i=0; i < SeqList->length; i++) {
        printf("初始值: Data[%d] = %c\n",i,SeqList->data[i]);
    }
}

bool InsterList(SeqList *L, char ch, int i)
{
    if (i < 1 || i > L->length+1) { // 索引超出范围
        return false;
    }
    if (L->length >= L->maxSize) { // 数组已满
        return false;
    }
    for (int j=L->length; j>i; j--) { // 后移元素
        L->data[j] = L->data[j-1];
    }
    L->data[i] = ch;
    L->length++;
    return true;
}
```



### 1.3 链表

#### 带头结点 ---- 向链表头写入数据

```c
/*
	带头结点 --- 向链表头写入数据 --- 插入信息
*/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>


typedef struct LNode{
    int data;
    struct LNode *next;
} LNode,*LinkList;

LinkList InitLinkList(LinkList L); // 初始化链表
bool InterHead(LinkList L);     // 向链表头部写入数据
bool InterNext(LinkList L);     // 向链表尾部写入数据
bool InterLNode(LinkList L, int data, int i); // 向链表中插入数据
bool DeleteLNode(LinkList L, int data, int* i); //删除指定数据，并传回位置信息i
// bool DeleteLNode(LinkList L, int i, int *data); //删除指定位置数据，并传回删除的数据信息data
void PrintLinkList(LinkList L); // 打印链表所有数据

int main() 
{
    LinkList L;
    L = InitLinkList(L);  //初始化链表

    //写入链表头尾部
    for (int i=0; i<3; i++) {
        if(InterHead(L)) {
            printf("向头部写入成功！\n"); 
        } else {
            printf("向头部写入失败！");
        }
    }
    PrintLinkList(L); // 打印链表信息
    
    // 向链表插入信息
    if (InterLNode(L,10,1)) { 
        printf("插入成功！\n");
    } else {
        printf("插入失败\n");
    }
    PrintLinkList(L); // 打印链表信息

   
    // 删除指定数据
    int i=0;
    int data = 3;
    if (DeleteLNode(L,data,&i)) {
        printf("成功删除了第%d个数据%d!\n",i,data);
    } else {
        printf("链表里没有数据%d!\n",data);
    }
    PrintLinkList(L); // 打印链表信息

    return 0;
}

// 初始化链表
LinkList InitLinkList(LinkList L)
{
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;
    // L = NULL;
    printf("初始化成功！\n");
    return L;
}

// 向链表头部写入数据
bool InterHead(LinkList L)
{
    int ch;
    scanf("%d",&ch);

    LNode* lnode;
    lnode = (LNode *)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
    lnode->data = ch;
    lnode->next = L->next;
    L->next = lnode;  //L指向的地址没有变，变的只是地址里的值
    return true;
}

// 向链表插入数据
bool InterLNode(LinkList L, int data, int i)
{
    if (i<1) return false;
    // if (i=1)
    // 确定插入位置
    LNode *p = L;
    for (int j = 0; j<i-1; j++) {
        p = p->next;
        if (p==NULL) // 超过链表长度
            return false; 
    }
    // 插入操作
    LNode *lnode;
    lnode = (LNode*)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
    lnode->data = data;
    lnode->next = p->next;
    p->next = lnode;

    return true;
}

bool InterNext(LinkList L)
{
    int ch;
    scanf("%d",&ch);

    LNode* lnode;
    lnode = (LNode *)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
}

//删除指定数据，并传回位置信息i
/* 
    宝典：
*/
bool DeleteLNode(LinkList L, int data, int* i)
{
    LNode* p1 = L;
    LNode* p2 = L; //延迟一拍
    while(1) {
        p1 = p1->next;
        if (p1 == NULL) return false;// 链表尾部
        if (p1->data == data) {
            // LNode* q = p1->next;
            // p1->next = q->next;
            p2->next = p1->next;
            free(p1);
            break;
        }
        p2 = p2->next;
    }
    return true;
}


// 打印链表所有数据
void PrintLinkList(LinkList L)
{
    int i = 0;
    LNode *p = L;
    while (p!= NULL) {
        if (i==0) {   // 首节点为空不打印
            p = p->next;
            ++i;
            continue;
        }
        printf("%d: %d\n",i++,p->data);
        p = p->next;
    }
    printf("\n");
}
```

#### 带头结点写字符串

```c
/*
	带头结点 --- 向链表头写入数据 --- 插入信息
*/

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define maxsize 100
typedef char sttint;

typedef struct LNode{
    sttint data[maxsize];
    struct LNode *next;
} LNode,*LinkList;

LinkList InitLinkList(LinkList L); // 初始化链表
bool InterHead(LinkList L);     // 向链表头部写入数据
bool InterNext(LinkList L);     // 向链表尾部写入数据
bool InterLNode(LinkList L, sttint* data, int i); // 向链表中插入数据
bool DeleteLNode(LinkList L, sttint* data, int* i); //删除指定数据，并传回位置信息i
// bool DeleteLNode(LinkList L, int i, int *data); //删除指定位置数据，并传回删除的数据信息data
void PrintLinkList(LinkList L); // 打印链表所有数据

int main() 
{
    LinkList L;
    L = InitLinkList(L);  //初始化链表

    //写入链表头尾部
    for (int i=0; i<3; i++) {
        if(InterHead(L)) {
            printf("向头部写入成功！\n"); 
        } else {
            printf("向头部写入失败！");
        }
    }
    PrintLinkList(L); // 打印链表信息
    
    // 向链表插入信息
    sttint interdata[10] = "10";
    if (InterLNode(L,interdata,1)) { 
        printf("插入成功！\n");
    } else {
        printf("插入失败\n");
    }
    PrintLinkList(L); // 打印链表信息

   
    // 删除指定数据
    int i = 0;
    sttint data[10];
    printf("请输入要删除的数据：");
    scanf("%s", data);
    if (DeleteLNode(L,data,&i)) {
        printf("成功删除了第%d个数据%s!\n",i,data);
    } else {
        printf("链表里没有数据%s!\n",data);
    }
    PrintLinkList(L); // 打印链表信息

    return 0;
}

// 初始化链表
LinkList InitLinkList(LinkList L)
{
    L = (LNode*)malloc(sizeof(LNode));
    L->next = NULL;
    // L = NULL;
    printf("初始化成功！\n");
    return L;
}

// 向链表头部写入数据
bool InterHead(LinkList L)
{
    sttint ch[10];
    scanf("%s",ch);

    LNode* lnode;
    lnode = (LNode *)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
    strcpy(lnode->data, ch);
    lnode->next = L->next;
    L->next = lnode;  //L指向的地址没有变，变的只是地址里的值
    return true;
}

// 向链表插入数据
bool InterLNode(LinkList L, sttint* data, int i)
{
    if (i<1) return false;
    // if (i=1)
    // 确定插入位置
    LNode *p = L;
    for (int j = 0; j<i-1; j++) {
        p = p->next;
        if (p==NULL) // 超过链表长度
            return false; 
    }
    // 插入操作
    LNode *lnode;
    lnode = (LNode*)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
    strcpy(lnode->data, data);
    lnode->next = p->next;
    p->next = lnode;

    return true;
}

bool InterNext(LinkList L)
{
    int ch;
    scanf("%d",&ch);

    LNode* lnode;
    lnode = (LNode *)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return false;
}

//删除指定数据，并传回位置信息i
/* 
    宝典：
*/
bool DeleteLNode(LinkList L, sttint* data, int* i)
{
    LNode* p1 = L;
    LNode* p2 = L; //延迟一拍
    while(1) {
        p1 = p1->next;
        if (NULL == p1) return false;// 链表尾部
        if (strcmp(p1->data,data) == 0) {
            // LNode* q = p1->next;
            // p1->next = q->next;
            p2->next = p1->next;  
            free(p1);
            break;
        }
        p2 = p2->next;
    }
    return true;
}


// 打印链表所有数据
void PrintLinkList(LinkList L)
{
    int i = 0;
    LNode *p = L;
    while (p!= NULL) {
        if (i==0) {   // 首节点为空不打印
            p = p->next;
            ++i;
            continue;
        }
        printf("%d: %s\n",i++,p->data);
        p = p->next;
    }
    printf("\n");
}
```



#### 不带头结点、头写

```c
/*
	不带头结点、头写
*/
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

typedef struct LNode{
    int data;
    struct LNode *next;
} LNode,*LinkList;

// 初始化链表
LinkList InitLinkList(LinkList L);

// 向链表头部写入数据
LinkList HeadInter(LinkList L);
// bool InterLNode(LinkList L, LNode *p1, LNode *p2);

// 打印链表所有数据
void PrintLinkList(LinkList L);

int main() 
{

    LinkList L;

    //初始化链表
    L = InitLinkList(L); 

    //写入链头尾部
    for (int i=0; i<4; i++) {
        L = HeadInter(L);
            printf("向头部写入成功！\n"); 
    }

    // 打印链表信息
    PrintLinkList(L);
}

LinkList InitLinkList(LinkList L)
{
    // L = (LNode*)malloc(sizeof(LNode));
    // L->next = NULL;
    L = NULL;
    printf("初始化成功！\n");
    return L;
}

LinkList HeadInter(LinkList L)
{
    int ch;
    scanf("%d",&ch);

    LNode* lnode;
    lnode = (LNode *)malloc(sizeof(LNode));
    if (lnode == NULL) //申请失败
        return L;
    printf("链表为空！\n");
    lnode->data = ch;
    lnode->next = L;
    L = lnode;  //L指向的地址发生了改变，所以L需要被反回
    return L;
}

void PrintLinkList(LinkList L)
{
    int i = 0;
    LNode *p = L;
    while (p!= NULL) {
        printf("%d: %d\n",i++,p->data);
        p = p->next;
    }
    // for (int i=0; i<4; i++) {
    //     printf("%d: %d\n",i,p->data);
    //     p = p->next;
    // }
}
```



#### 图书管理系统

```c
/*  // 图书管理系统 
    // 单链表实现
    // 增、查
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

typedef struct LNBook { // 4+64+4+8=80字节
    int id;
    char name[64];
    float price;
    struct LNBook* next;
} LNBook, *PLNBook; //LNBook 表示一个节点；PLNBook 表示一个链表

PLNBook InitPLNBook(PLNBook head); // 初始化链表 （链表头）
bool AddLNBook(PLNBook head, int id, char* name, float price); // 图书信息添加到链表中 
LNBook* SearchBook(PLNBook head, char* name, size_t n); // 根据书名查找图书信息 （链表头，图书名字，名字长度）

void InputBook(int* id, char* name, float* price); // 输入图书信息 
void PrintfPLNBook(PLNBook head); // 打印链表所有信息
void PrintfLNBook(LNBook lnBook); // 打印链表的一个节点信息

int main(int argc, char const *argv[]) 
{
    PLNBook head;
    LNBook* lnbook;
    LNBook lnBook;
    printf("size lnBook %ld\n",sizeof(lnBook));
    printf("size st %ld\n",sizeof(LNBook));
    printf("size pt %ld\n",sizeof(PLNBook));
    printf("size int %ld\n",sizeof(head));

    // 初始化
    head = InitPLNBook(head);
    printf("size int %ld\n",sizeof(head));

    int number;
    int id;
    char name[64];
    float price;

    // 添加图书信息
    printf("请输入要添加的书本数：");
    scanf("%d",&number);
    for (int i=0; i<number; ++i) {
        InputBook(&id, name, &price); // 输入图书信息
        if (AddLNBook(head, id, name, price)) { // 添加到链头
            printf("添加成功！\n");
        } else {
            printf("添加失败！\n");
        }
    }

    // 打印链表图书信息
    PrintfPLNBook(head);

    // 查找图书
    printf("请输入要查找的书籍名：");
    scanf("%s",name);
    lnbook = SearchBook(head, name, strlen(name)); //返回图书节点

    return 0;
}

void InputBook(int *id, char *name, float *price)
{
    printf("请输入图书id: ");
    scanf("%d", id);
    while (getchar() != '\n');
    printf("请输入图书名称: ");
    scanf("%s", name);
    printf("请输入图书价格: ");
    scanf("%f", price);
    while (getchar() != '\n');
}

PLNBook InitPLNBook(PLNBook head) 
{
    head = (PLNBook)malloc(sizeof(LNBook));
    printf("初始化函数内sizeof head: %ld\n",sizeof(head));
    head->id = 0;
    head->name[0] = '\0';
    head->price = 0.0;
    head->next = NULL; //带头结点初始化
    return head;
}

bool AddLNBook(PLNBook head, int id, char* name, float price) 
{
    LNBook *p;
    p = (LNBook*)malloc(sizeof(LNBook));
    if (NULL == p) {
        printf("内存申请失败！");
        return false;
    }
    p->id = id;
    strcpy(p->name,name);
    p->price = price;
    p->next = head->next; //添加到链表头
    head->next = p;
    return true;
}

LNBook* SearchBook(PLNBook head, char* name, size_t n)
{
    LNBook* p = head, *q = head;
    while (NULL != p->next) {
        p = p->next;
        if (strncmp(p->name, name, n) == 0) { // 正则表达式暂不会
            PrintfLNBook(*p);
            return p;
        }
        q = q->next;
    }
    p = NULL;
    printf("没有找到相关书籍！\n");
    return p;
}

void PrintfPLNBook(PLNBook head) 
{
    LNBook *p = head;
    int i=0;
    printf("\n");
    while(NULL != p->next) { //注意指针越界
        // if (i==0) { // 不打印头结点
        //     ++i;
        //     p = p->next;
        //     continue;
        // }
        p = p->next;
        PrintfLNBook(*p);
        ++i;
    }
    printf("共打印了%d个数据!\n",i);
}

void PrintfLNBook(LNBook lnBook) 
{
    printf("id: %d; ",lnBook.id);
    printf("name: %s; ",lnBook.name);
    printf("price: %.2f;\n",lnBook.price);
}

```













### 1.4 内核链表

#### **容器**

首先要理解，所有的数据结构本质上是一种容器，包括已经学习了的顺序表、链表，以及后续将会学习的栈、队列、二叉树等等。所谓容器，指的是==**只关心其内部数据之间的逻辑关系，并提供与这种逻辑关系相对应的操作的集合。**==容器不关心数据本身的类型，因为对于容器而言，不管是存储一个整数，还是存储一个进程，还是一个学生、一本图书，它们都被称为一个数据节点。

#### 2. 通用性

容器提供的是数据处理的通用解决方案，即：提供一套可以处理任意数据类型的通用API，不管是什么数据，都可以统一处理。比如链表，不管处理什么数据，对它们的操作都是统一的：初始化、插入、删除、遍历、销毁等等。

目前，有两种常见的方式来获得通用性：

- 创建容器时，让用户提供数据的类型。典型应用案例是STL（一个C++的类库）
- ==将数据从容器中剥离出去，让容器只提供逻辑。==典型应用案例是==Linux内核链表==

由于C语言没有类，也不支持重载，受语言本身特性的限制，一般不使用第一种办法来设计通用容器，但在一些小型程序中，C语言也是可以实现通用性的，关键在于：让用户提供数据的类型。而容器本身只处理跟数据逻辑结构相关的操作，凡是涉及具体数据的操作，一律要让用户来提供。

下面以双向链表为例，使用上述第一种方法，将其改造成通用的容器。

#### 3. 节点设计

```c
// list.h

#ifndef DATATYPE
#define DATATYPE int
#endif

typedef DATATYPE datatype;

// 此处的节点是通用的
// 原理是将具体数据的类型让渡给用户自己去定义
typedef struct node
{
    datatype data;

    struct node *prev;
    struct node *next;
}listnode, *linklist;
```

以上代码有几处需要着重解释：

- 上述代码必须写在 *.h 头文件中，而不是 *.c 源文件
- 用户使用该容器的时候，定义 DATATYPE 为其所需要的数据类型

许多人比较困惑的地方在于，既然用户需要提供数据，那为什么不直接让用户定义datatype，而要去定义宏 DATATYPE 呢？原因是 ==typedef 无法跟宏一样，给用户提供一个默认的数据类型。==

接下来，对于跟用户数据无关的操作，无需任何修改，直接就是通用的，比如初始化、判断是否为空：

```c
// 注意以下内容必须放在头文件 list.h 中

// 初始化空链表，与用户实际数据无关
static node * initList()
{
    node * head = (node *)malloc(sizeof(node));

    if(head != 0)
    {
        head->prev = head;
        head->next = head;
    }

    return head;
}

// 判断链表是否为空，与用户实际数据无关
static bool isEmpty(node *head)
{
    return head->next == head;
}
```

**注意1：**
通用型算法一律都只能写到头文件 list.h 中，因为编译的时候 datatype 必须结合用户提供的 *.c 源文件才能确定切确的类型，如果单独编辑 list.c，那么在编译产生 list.o 的过程中就无法使用用户所指定的类型。

**注意2：**
通用型算法代码 list.h 的使用方法，就是直接作为头文件放在用户程序中即可，如果用户需要使用链表容器处理其特定的数据，那么就在包含头文件前自定义宏 DATATYPE 如：

```
#define DATATYPE xxx // xxx为用户自定义的任意数据类型
#include "list.h"
```

**注意3：**
为防止头文件被多个C文件包含而造成函数冲突，头文件中的所有函数必须被定义为静态存储类型。

#### 4. 增删改

提醒：
==不对外的函数接口，一般使用下划线开头，比如 __newNode()==

```c
// 根据用户提供的数据，产生一个新节点
static linklist __newNode(datatype *newData)
{
    linklist new = malloc(sizeof(listnode));
    if(new != NULL)
    {
        new->data = *newData;
        new->prev = new;
        new->next = new;
    }

    return new;
}

// 将新节点new插入到链表的首部
void listAdd(linklist head, datatype *newdata)
{
    linklist new = __newNode(newdata);

    new->prev = head;
    new->next = head->next;

    head->next->prev = new;
    head->next = new;
}

// 将新节点new插入到链表的尾部
void listAddTail(linklist head, datatype *newdata)
{
    linklist new = __newNode(newdata);

    new->prev = head->prev;
    new->next = head;

    head->prev->next = new;
    head->prev = new;
}

// 将指定节点从链表中剔除出去
bool listDel(linklist p)
{
    if(p==NULL || isEmpty(p))
        return false;

    // 将原链表首节点剔除出链表
    p->prev->next = p->next;
    p->next->prev = p->prev;
    p->prev = p;
    p->next = p;

    return true;
}
```



#### 5. 查找节点

在链表中查找某个节点也是一种常规操作，但查找操作与上述的增删操作有个很大的不同，节点的比对是跟节点本身数据密切相关的，比如整型数据可以直接使用等号来判断是否一致，而字符串则需要通过特定的函数才能判断，至于结构体，则无法使用任何现成的方式去判定，==只能由用户根据其实际数据去判定==。

因此，查找节点时，==**节点的判定接口**必须由用户提供==，链表只提供回调接口

```c

// 链表只提供回调接口
linklist find(linklist head, datatype data,
                bool (*equal)(datatype, datatype))
{
    for(linklist tmp=head->next; tmp!=head; tmp=tmp->next)
    {
        if(equal(tmp->data, data))
            return tmp;
    }
    return NULL;
}

```









## 树

概念：树由一个根节点和若干子节点构成，每一个非叶节点的子节点又个看做一个根节点。

它的这种结构使得能高效的递归的遍历他。

![image-20240614154729396](./assets/assets.数据结构/image-20240614154729396.png)









## 4、排序

### 快速排序

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>


void InitArr(int arr[], int len, int start, int end); //初始化
void ShowArr(int arr[], int len); //显示数组
void QuickSort(int arr[], int left, int right); //快速排序
int  Partition(int arr[], int left, int right); //块排序
void ReverseArr(int arr[], int len); //逆转数组

int main()
{
    int a = 10;
    int arr[a];
    InitArr(arr, a, 1, 10*a);
    ShowArr(arr, a);

    QuickSort(arr, 0, a-1);
    ShowArr(arr, a);

    ReverseArr(arr,a);
    ShowArr(arr, a);

    return 0;
}

void InitArr(int arr[], int len, int start, int end) {
    for (int i = 0; i < len; i++) {
        arr[i] = rand()%(end - start) + start;;
    }
    printf("初始化成功！\n");
}

void ShowArr(int arr[], int len) {
    for (int i = 0; i < len; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int Partition(int arr[], int left, int right)  {
    int pivot = arr[left];  // 第一个数作为基准
    while (left < right)
    {   
        //遍历右边，直到遇到比基准小的
        while (left < right && arr[right] >= pivot) --right; 
        //右边小的移到左边
        arr[left] = arr[right];
        while (left < right && arr[left] <= pivot) ++left; 
        arr[right] = arr[left];
    }
    arr[left] = pivot;  //将基准数插入到左右相等位置
    return left;        //返回左右相等的地址
}

void QuickSort(int arr[], int left, int right) {
    if (left < right) {
        int pivot = Partition(arr, left, right);
        QuickSort(arr, left, pivot - 1);
        QuickSort(arr, pivot + 1, right);
    }
}

void ReverseArr(int arr[], int len) {
    int carr[len];
    for (int i=0; i<len; ++i) {
        carr[len-i-1] = arr[i];
    }
    for (int i=0; i<len; ++i) {
        arr[i] = carr[i];
    }
}
```













# runoob

https://www.runoob.com/data-structures/shell-sort.html

### 常见的数据结构

- **栈（Stack）：**栈是一种特殊的线性表，它只能在**一个表的一个固定端**进行数据结点的插入和删除操作。
- **队列（Queue）：**队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的**一端进行插入操作，而在另一端进行删除操作**。
- **数组（Array）：**数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
- **链表（Linked List）：**链表是一种数据元素**按照链式存储结构**进行存储的数据结构，这种存储结构具有**在物理上存在非连续的特点**。
- **树（Tree）：**树是典型的非线性结构，它是包括，**2 个结点的有穷集合 K**。
- **图（Graph）：**图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- **堆（Heap）：**堆是一种**特殊的树形数据结构**，一般讨论的堆都是二叉堆。
- **散列表（Hash table）：**散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

### 常用算法

数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：

- **检索：**检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。
- **插入：**往数据结构中增加新的节点。
- **删除：**把指定的结点从数据结构中去掉。
- **更新：**改变指定节点的一个或多个字段的值。
- **排序：**把节点按某种指定的顺序重新排列。例如递增或递减。

## 1、排序

### 1.1 插入排序

#### 概念及其介绍

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表

。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

#### 适用说明

插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 **N-1** 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。

#### 过程图示

假设前面 **n-1**(其中 **n>=2**)个数已经是排好顺序的，现将第 **n** 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。

按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。

从小到大的插入排序整个过程如图示：

<img src="./assets/assets.数据结构/InsertSort-01.png" alt="img" style="zoom:50%;" />

**第三轮：**第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。

<img src="./assets/assets.数据结构/InsertSort-03.png" alt="img" style="zoom:50%;" />



### 1.2 希尔排序

#### 概念及其介绍

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

**它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。**

#### 适用说明

希尔排序时间复杂度是 **O(n^(1.3-2))**，空间复杂度为常数阶 **O(1)**。希尔排序没有时间复杂度为 **O(n(logn))** 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 **O(n^2 )** 复杂度的算法快得多。

#### 过程图示

希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

在此我们选择增量 **gap=length/2**，缩小增量以 **gap = gap/2** 的方式，用序列 **{n/2,(n/2)/2...1}** 来表示。

如图示例：

（1）初始增量第一趟 **gap = length/2 = 4**

<img src="./assets/assets.数据结构/ShellSort-01.png" alt="img" style="zoom: 50%;" />

（2）第二趟，增量缩小为 2

<img src="./assets/assets.数据结构/ShellSort-02.png" alt="img" style="zoom: 67%;" />

（3）第三趟，增量缩小为 1,得到最终排序结果

<img src="./assets/assets.数据结构/ShellSort-03.png" alt="img" style="zoom:67%;" />



### 1.3 归并排序

（不明白什么意思）

#### 概念及其介绍

归并排序（Merge sort）是建立在**归并操作**上的一种有效、稳定的排序算法，该算法是采用**分治法(Divide and Conquer）**的一个非常典型的应用。

**将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。**

#### 适用说明

当有 n 个记录时，需进行 logn 轮归并排序，每一轮归并，其比较次数不超过 n，元素移动次数都是 n，因此，归并排序的时间复杂度为 O(nlogn)。归并排序时需要和待排序记录个数相等的存储空间，所以空间复杂度为 O(n)。

归并排序适用于**数据量大**，并且对**稳定性有要求**的场景。

#### 过程图示

归并排序是**递归算法**的一个实例，这个算法中基本的操作是合并两个已排序的数组，取两个输入数组 A 和 B，一个输出数组 C，以及三个计数器 i、j、k，它们初始位置置于对应数组的开始端。

A[i] 和 B[j] 中较小者拷贝到 C 中的下一个位置，相关计数器向前推进一步。
当两个输入数组有一个用完时候，则将另外一个数组中剩余部分拷贝到 C 中。

<img src="./assets/assets.数据结构/MergeSort-01.png" alt="img" style="zoom: 80%;" />

自顶向下的归并排序，递归分组图示：

<img src="./assets/assets.数据结构/MergeSort-02.png" alt="img" style="zoom: 50%;" />

对第三行两个一组的数据进行归并排序

<img src="./assets/assets.数据结构/MergeSort-03.png" alt="img" style="zoom: 50%;" />

对第二行四个一组的数据进行归并排序

<img src="./assets/assets.数据结构/MergeSort-05.png" alt="img" style="zoom: 50%;" />

整体进行归并排序

<img src="./assets/assets.数据结构/MergeSort-04.png" alt="img" style="zoom: 50%;" />

### 1.4 随机化快速排序

#### 概念及其介绍

快速排序由 C. A. R. Hoare 在 1960 年提出。

**随机化快速排序基本思想：**通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

#### 适用说明

快速排序是一种比较快速的排序算法，它的平均运行时间是 **O(nlogn)**，之所以特别快是由于非常精练和高度优化的内部循环，最坏的情形性能为 **O(n^2)**。像归并一样，快速排序也是一种分治的递归算法。从空间性能上看，快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归，空间复杂度也为**O(logn)。**

#### 过程图示

在一个数组中选择一个基点，比如第一个位置的 4，然后把4挪到正确位置，使得之前的子数组中数据小于 4，之后的子数组中数据大于 4，然后逐渐递归下去完成整个排序。

<img src="./assets/assets.数据结构/quickSort-01.png" alt="img" style="zoom:50%;" />

如何和把选定的基点数据挪到正确位置上，这是快速排序的核心，我们称为 Partition。

过程如下所示，其中 **i** 为当前遍历比较的元素位置：

<img src="./assets/assets.数据结构/quickSort-02.png" alt="img" style="zoom: 67%;" />

